ARRIVAL LOGOGLYPH GENERATOR
import React, { useState, useRef, useEffect } from 'react';
import { Slider } from '@/components/ui/slider';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { RotateCw, Download, Trash, Layers } from 'lucide-react';

const HeptapodGlyphGenerator = () => {
  const [paths, setPaths] = useState([]);
  const [isDrawing, setIsDrawing] = useState(false);
  const [rotation, setRotation] = useState(0);
  const [symmetryCount, setSymmetryCount] = useState(6);
  const [brushSize, setBrushSize] = useState(8);
  const [brushOpacity, setBrushOpacity] = useState(1);
  const [splatter, setSplatter] = useState(false);
  const [currentPath, setCurrentPath] = useState([]);
  const [layers, setLayers] = useState([{ paths: [], visible: true }]);
  const [activeLayer, setActiveLayer] = useState(0);
  const [text, setText] = useState('');
  const svgRef = useRef(null);

  const CANVAS_SIZE = 400;
  const CENTER = CANVAS_SIZE / 2;

  // Convert point to polar coordinates relative to center
  const toPolar = (x, y) => {
    const dx = x - CENTER;
    const dy = y - CENTER;
    const radius = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    return { radius, angle };
  };

  // Convert polar coordinates back to cartesian
  const toCartesian = (radius, angle) => {
    const x = CENTER + radius * Math.cos(angle);
    const y = CENTER + radius * Math.sin(angle);
    return { x, y };
  };

  // Create symmetrical points around the circle
  const createSymmetricalPoints = (x, y) => {
    const { radius, angle } = toPolar(x, y);
    const points = [];
    
    for (let i = 0; i < symmetryCount; i++) {
      const newAngle = angle + (2 * Math.PI * i) / symmetryCount;
      const { x: newX, y: newY } = toCartesian(radius, newAngle);
      points.push({ x: newX, y: newY });
    }
    
    return points;
  };

  // Handle mouse/touch movement
  const handleMove = (e) => {
    if (!isDrawing) return;

    const svg = svgRef.current;
    const rect = svg.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    setCurrentPath(prev => [...prev, ...createSymmetricalPoints(x, y)]);
  };

  // Create SVG path from points
  const createPathString = (points) => {
    if (points.length === 0) return '';
    
    let path = `M ${points[0].x} ${points[0].y}`;
    for (let i = 1; i < points.length; i++) {
      path += ` L ${points[i].x} ${points[i].y}`;
    }
    return path;
  };

  // Handle path completion
  const completePath = () => {
    if (currentPath.length > 0) {
      const updatedLayers = [...layers];
      updatedLayers[activeLayer].paths = [...updatedLayers[activeLayer].paths, currentPath];
      setLayers(updatedLayers);
      setCurrentPath([]);
    }
    setIsDrawing(false);
  };

  // Export as SVG or PNG
  const exportImage = (format = 'svg') => {
    if (format === 'svg') {
      const svgData = svgRef.current.outerHTML;
      const blob = new Blob([svgData], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `heptapod-glyph-${text || 'untitled'}.svg`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    } else if (format === 'png') {
      const svgElement = svgRef.current;
      const svgData = new XMLSerializer().serializeToString(svgElement);
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      const img = new Image();
      canvas.width = CANVAS_SIZE;
      canvas.height = CANVAS_SIZE;
      img.onload = () => {
        context.drawImage(img, 0, 0);
        const pngUrl = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = pngUrl;
        link.download = `heptapod-glyph-${text || 'untitled'}.png`;
        document.body.appendChild(link);
        link.click
